/list get lista servicios requeridos

/login post por body recibe email y password
     crea token 

/register post body recibe nombre(obligatorio) email(obligatorio) biografia avatar

/addservice post body recibe titulo(obligatorio) explicacion(obligatorio) fichero

/replyservice recibe el id del servicio, post de comentario(obligatorio) y fichero

/done post recibe idservicio idusuario, modifica cambio de no echo a echo el servicios

middleware de token para autentificar las siguientes peticiones


///////////////////////////////////////////////////////////////////////////////////


Mis comentarios sobre el proyecto. Si necesitÃ¡is ayuda, crear ticket.

Comentarios:

- âœ… en gitHub veo que cada uno aportÃ³ algo

- ğŸ…°ï¸ en readme.md: no se describen todos los endpoint; faltarÃ­an las instrucciones para levantar la API (.env, npm i, DB, ... )

- ğŸ…°ï¸ int(10) deprecated. Usar int

- âœ… "active" utilizar BOOLEN

- ğŸ…°ï¸ No usar la variable de entorno USER, en algunos SO corresponde con el usuario de sistema (a mÃ­ me cogÃ­a siempre usuario "stefano" de sistema, la cambiÃ© por mysqluser)

- âœ… require('dotenv').config() aconsejo siempre como primera lÃ­nea. Evita problemas si antes hacemos import de mÃ³dulos que necesitan las variables de entorno.

- ğŸ…°ï¸ poner el puerto API como configurable (en .env)

- ğŸ…°ï¸ Â¿Token en la tabla user y en el esquema Joi? No se usa. Eliminar.

- âœ… âœ… âœ… Problema grave: no siempre se hace la release de la connexiÃ³n a BD (por ej en caso de error).
connect.release() en el finally del try/catch porque se hay un error en el bloque de cÃ³digo try/catch, antes de connect.release, la conexiÃ³n no se cierra. Esto provoca que si esto pasa 10 veces, acaba el pool de concesiones y la API acaba de funcionar (se pone a la espera de conexiones a DB). Revisar en todos los endpoint y middlewares.

- âœ… âœ… âœ… en dataValidation no res.send(error), usar middleware de los errores (next(error)). Comprobar en toda la API.

- ğŸ…°ï¸ falta revisar en toda la api âœ… en newUser no se usa Joi, eliminar: const Joi = require('joi'). Revisar en toda la API los import no utilizados.

- ğŸ…°ï¸ mirar la gestion de ficheros âœ… Â¿Avatar en newuser? Â¿En new user avatar tendrÃ­a que ser la img avatar del usuario? No se gestiona. Quitar avatar en creaciÃ³n usuario

- ğŸ…°ï¸ya comente unos cuantos jaja âœ… eliminar o commentar console.log/console.error de debug

- ğŸ…°ï¸ en sendMail poner configurable en .env "http://localhost:4000/confirm/". SerÃ¡ Ãºtil cuando haremos deploy y la API no estarÃ© en localhost.

- ğŸ…°ï¸ from de sendGrid ponerlo en .env. Si uso mi KEY, sendgrid no funciona con el remitente 'habgrupoe@gmail.com'

- âœ… âœ… âœ… que bonito el cuerpo del correo de validaciÃ³n

- ğŸ…°ï¸ mirar al hacer cambios para front ğŸ…°ï¸ En general, no solo en validaciÃ³n usuario, devolver siempre un objeto JSON con misma estructura { status: "", message:"" data: "" }. Y no a veces un string y a veces un objeto, ... Revisar todos los endPoint y middleware. Â¿Porque esto? AsÃ­ el desarrollador Front no tendrÃ¡ que poner lÃ³gica por cada peticiÃ³n, la API devolverÃ¡ siempre la misma estructura de JSON.

- ğŸ…°ï¸ problema de seguridad: no utilizar id usuario para validar ( http://localhost:4000/confirm/${id}). Generar en fase de creaciÃ³n usuario un cÃ³digo unÃ­voco (ej con uuid) que guardo en DB y cuando se valida pongo usuario validado y borro este cÃ³digo. (ej en https://gitlab.com/blueoceanstart/hack-a-boss/jsb18rt/tutorias/-/blob/main/08052023_repasoExpress/diarioDeViajes). Â¡Esto porque, por como lo tenÃ©is, podrÃ­a fÃ¡cilmente validar un usuario reciÃ©n creado con email de otra persona simplemente haciendo "http://localhost:4000/confirm/123!!!"

- ğŸ…°ï¸ por quÃ© confirmMail en middlewares? Es un endpoint/controlador.

- ğŸ…°ï¸ Se permite validar un usuario mÃ¡s veces. Si ya lo validÃ© tendrÃ­a que decir ya validado o ningÃºn usuario por validar

- âœ… no hace falta poner active en el token

- âœ… âœ… âœ… devolverÃ­a, en el login, las infos id y e-mail/nombre usuario para poderlas visualiza/gestionar con React!

- ğŸ…°ï¸ JOI para validar en todos los endpoint (futuro).

- âœ… âœ… âœ… En catch de getUser no console.error, ir a middleware de los errores. Hacer un check en toda la API.

- âœ… metido validacion de usuario para que solo retorne el user logueado âœ… getUser devuelve todos los datos!! Incluida pwd! No. Devolver solo los datos que el front pueda necesitar. PasarÃ­a por isUser (token obligatorio)

- âœ… "usuario no encontrado" es uno status code 404

- ğŸ…°ï¸ Incoherencia: cuando creo usuario pwd: Joi.string().min(8).max(45).required() y en el cambio pwd me deja poner "1234"

- âœ… âœ… âœ… en modifica usuario devolver los datos del usuario en el JSON

- ğŸ…°ï¸ falta definir users (le cambiarÃ­a nombre por uploads) como static para poder acceder desde front a la foto con "http://localhost:4000/avatar/18253cb5-fb65-45a6-b39e-2eb6d6700993.jpg"

- ğŸ…°ï¸ guardar en DB /avatar/18253cb5-fb65-45a6-b39e-2eb6d6700993.jpg, no solo "18253cb5-fb65-45a6-b39e-2eb6d6700993.jpg". Esto porquÃ© gestionais subcarpetas en users (directorio static)

- ğŸ…°ï¸ HacÃ©is un borrado lÃ³gico del usuario, bien. Pero tenÃ©is que borrar la info sensible con el update a la base de datos (email, pwd, ...) porque si el usuario vuelve a registrarse le darÃ­a correo ya utilizado! AdemÃ¡s cuidado con el borrado lÃ³gico, si hacÃ©is un getUser del usuario borrado devuelve los datos. Si un usuario estÃ¡ borrado, hay que considerarlo como inexistente. Revisar en toda la API.

- ğŸ…°ï¸ porque router.get('/mail/:mail', sendMail) como endpoint? Â¿Eliminar, no?

- âœ… eliminar const { dirname } = require('path') en upload

- ğŸ…°ï¸ DRY: uploads, UploadComm y uploadAvatar son iguales (solo cambia /../users/services, /../users/avatar, /../users/coments)! Pasar path como parÃ¡metro y unificar. Pero no creo que haga falta gestionar sub carpetas en directorio estÃ¡tico si los ficheros tienen nombre unÃ­vocos. Guardamos en "users" todo (avatar, ficheros de las necesidades y ficheros comentarios)

- âœ… metida response en .send âœ… cuando se crea un servicio devolver los datos del servicio creado

- ğŸ…°ï¸ yo creo que se entiende mejor asi ;) âœ… AddService cÃ³digo duplicado: hacer solo una vez `INSERT INTO servicios.." con o sin fichero. No hace falta repetir:
response.affectedRows > 0
? res.send(`servicio creado corectamente!`)
: res.send(
'Problema con la conexiÃ³n con la base de datos :( porfavor,vuelve a intentarlo'
);
solo poniÃ©ndolo fuera del if/else no duplicarÃ­amos cÃ³digo.

- âœ… modificar bd âœ… falta requisito: Marcar un servicio requerido como ya resuelto. Solo el propietario del servicio podrÃ­a ponerlo como resuelto (gestionar BOOLEAN en DB) luego segÃºn los que tenÃ©is pensado de vuestra plataforma: marcar servicio como resuelto en el front pero dejar a los usuarios la posibilidad de comentar y subir soluciones (mÃ¡s fÃ¡cil) o permitir comentarios pero no subida de ficheros.

- âœ… ahora isUser comprueba fechas de update user y creacion token âœ… si elimino usuario y tengo el token no caducado podrÃ­a seguir utilizando la API. Hacer comprobaciÃ³n en middleware isUser. TambiÃ©n si cambio pwd tendrÃ­amos que invalidar el token (ej en https://gitlab.com/blueoceanstart/hack-a-boss/jsb18rt/tutorias/-/blob/main/08052023_repasoExpress/diarioDeViajes)

- ğŸ…°ï¸ pendiente gestionar con bd modificada ğŸ…°ï¸ en getService faltan datos usuarios de cada servicios para visualizarlos en el front, falta nÃºmero comentarios, si estÃ¡ resuelto o no...

- ğŸ…°ï¸ en getGervice implementaria en query params filtros y ordenaciÃ³n (mirar ejemplo en https://gitlab.com/blueoceanstart/hack-a-boss/jsb18rt/tutorias/-/blob/main/08052023_repasoExpress/diarioDeViajes/controllers/entries/listEntries.js )

- ğŸ…°ï¸ cuando aÃ±ado un commentario devolver todos los comentarios del servicio

- ğŸ…°ï¸ en crea comentario id servicio en param no en el body

- ğŸ…°ï¸ si aÃ±ado comentario en un servicio que no existe tengo un error SQL

- ğŸ…°ï¸ falta endpoint detalle servicio: devuelve datos del servicio y el listado de los comentarios (id, id user, email, fichero...)

Y... âœ… âœ… âœ… test, test, test. Un saludo,

Stefano